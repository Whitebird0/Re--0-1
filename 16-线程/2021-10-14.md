线程：TEB(3环) ETHREAD(0环)

FS:[0]指向TEB

TEB+0X30=FS:[30]=PEB

    HANDLE hThread1=CreateThread(NULL, NULL, ThreadCallBack1, NULL, NULL, NULL)//创建线程
    TerminateThread(hThread1,0)//结束线程
    SuspendThread(hThread1)//挂起线程，没有结束，相当于暂停
    ResumeThread(hThread1)//恢复线程
    
---    
      #include<stdio.h>
      #include<Windows.h>
      #include<TlHelp32.h>
      DWORD WINAPI ThreadCallBack1(LPVOID lp) {
        while (TRUE) {
          //printf("ThreadCallBack1\r\n");
        }
        return 0;
      }

      DWORD WINAPI ThreadCallBack2(LPVOID lp) {
        while (TRUE) {
          //printf("ThreadCallBack2\r\n");
        }
        return 0;
      }

      void showThread() {//遍历系统中的线程
        HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId());
          THREADENTRY32 te32 = { sizeof(THREADENTRY32) };
          BOOL bret = Thread32First(hThreadSnap, &te32);
          while (bret)
          {
            if (GetCurrentProcessId()==te32.th32OwnerProcessID)//只打印属于本进程的线程
            {
              printf("Thread id = %d\n", te32.th32ThreadID);
            }

            bret = Thread32Next(hThreadSnap, &te32);
          }
        }

      int main() {
        HANDLE hThread1 = CreateThread(NULL, NULL, ThreadCallBack1, NULL, NULL, NULL);
        HANDLE hThread2 = CreateThread(NULL, NULL, ThreadCallBack2, NULL, NULL, NULL);
        Sleep(5000);
        //SuspendThread(hThread1);//挂起的句柄
        //Sleep(5000);
        //ResumeThread(hThread1);
        TerminateThread(hThread1, 0);
        showThread();
        system("pause");

        //SuspendThread(hThread2);
        return 0;
      }
